///
/// RealtimeNotification.cs
/// CumulocityCoreLibrary
///
/// Copyright (c) 2014-2023 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.
/// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG.
///

using System.Collections.Generic;
using Com.Cumulocity.Client.Converter;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Runtime.Serialization;

namespace Com.Cumulocity.Client.Model 
{
	public class RealtimeNotification 
	{
	
		/// <summary> 
		/// Configuration parameters for the current connect message. <br />
		/// </summary>
		///
		[JsonPropertyName("advice")]
		public Advice? PAdvice { get; set; }
	
		/// <summary> 
		/// The channel name as a URI. <br />
		/// </summary>
		///
		[JsonPropertyName("channel")]
		public Channel? PChannel { get; set; }
	
		/// <summary> 
		/// Unique client ID generated by the server during handshake. Required for all other operations. <br />
		/// </summary>
		///
		[JsonPropertyName("clientId")]
		public string? ClientId { get; set; }
	
		/// <summary> 
		/// Selected connection type. <br />
		/// </summary>
		///
		[JsonPropertyName("connectionType")]
		public string? ConnectionType { get; set; }
	
		/// <summary> 
		/// List of notifications from the channel. <br />
		/// </summary>
		///
		[JsonPropertyName("data")]
		public Data? PData { get; set; }
	
		/// <summary> 
		/// Operation failure reason (only present if the operation was not successful). <br />
		/// </summary>
		///
		[JsonPropertyName("error")]
		public string? Error { get; set; }
	
		/// <summary> 
		/// Authentication object passed to handshake (only over WebSockets). <br />
		/// </summary>
		///
		[JsonPropertyName("ext")]
		public Ext? PExt { get; set; }
	
		/// <summary> 
		/// ID of the message passed in a request. Required to match the response message. <br />
		/// </summary>
		///
		[JsonPropertyName("id")]
		public string? Id { get; set; }
	
		/// <summary> 
		/// Minimum server-side Bayeux protocol version required by the client (in a request) or minimum client-side Bayeux protocol version required by the server (in a response). <br />
		/// </summary>
		///
		[JsonPropertyName("minimumVersion")]
		public string? MinimumVersion { get; set; }
	
		/// <summary> 
		/// Name of the channel to subscribe to. Subscription channels are available for <see href="#tag/Alarm-notification-API" langword="Alarms" />, <see href="#tag/Device-control-notification-API" langword="Device control" />, <see href="#tag/Event-notification-API" langword="Events" />, <see href="#tag/Inventory-notification-API" langword="Inventory" /> and <see href="#tag/Measurement-notification-API" langword="Measurements" />. <br />
		/// </summary>
		///
		[JsonPropertyName("subscription")]
		public string? Subscription { get; set; }
	
		/// <summary> 
		/// Indicates if the operation was successful. <br />
		/// </summary>
		///
		[JsonPropertyName("successful")]
		public bool? Successful { get; set; }
	
		/// <summary> 
		/// Connection types supported by both client and server, that is, intersection between client and server options. <br />
		/// </summary>
		///
		[JsonPropertyName("supportedConnectionTypes")]
		public List<string> SupportedConnectionTypes { get; set; } = new List<string>();
	
		/// <summary> 
		/// <see href="https://docs.cometd.org/current/reference/#_concepts_bayeux_protocol" langword="Bayeux protocol" /> version used by the client (in a request) or server (in a response). <br />
		/// </summary>
		///
		[JsonPropertyName("version")]
		public string? Version { get; set; }
	
		public RealtimeNotification() 
		{
		}
	
		public RealtimeNotification(Channel channel)
		{
			this.PChannel = channel;
		}
	
		/// <summary> 
		/// The channel name as a URI. <br />
		/// </summary>
		///
		[JsonConverter(typeof(EnumConverterFactory))]
		public enum Channel 
		{
			[EnumMember(Value = "/meta/handshake")]
			METAHANDSHAKE,
			[EnumMember(Value = "/meta/subscribe")]
			METASUBSCRIBE,
			[EnumMember(Value = "/meta/unsubscribe")]
			METAUNSUBSCRIBE,
			[EnumMember(Value = "/meta/connect")]
			METACONNECT,
			[EnumMember(Value = "/meta/disconnect")]
			METADISCONNECT
		}
	
		/// <summary> 
		/// Configuration parameters for the current connect message. <br />
		/// </summary>
		///
		public class Advice 
		{
		
			/// <summary> 
			/// Period (milliseconds) after which the server will close the session, if it doesn't received the next connect message from the client. Overrides server default settings for current request-response conversation. <br />
			/// </summary>
			///
			[JsonPropertyName("interval")]
			public int? Interval { get; set; }
		
			/// <summary> 
			/// Interval (milliseconds) between the sending of the connect message and the response from the server. Overrides server default settings for the current request-response conversation. <br />
			/// </summary>
			///
			[JsonPropertyName("timeout")]
			public int? Timeout { get; set; }
		
			public override string ToString()
			{
				var jsonOptions = new JsonSerializerOptions() 
				{ 
					WriteIndented = true,
					DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
				};
				return JsonSerializer.Serialize(this, jsonOptions);
			}
		}
	
	
		/// <summary> 
		/// List of notifications from the channel. <br />
		/// </summary>
		///
		public class Data 
		{
		
			public override string ToString()
			{
				var jsonOptions = new JsonSerializerOptions() 
				{ 
					WriteIndented = true,
					DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
				};
				return JsonSerializer.Serialize(this, jsonOptions);
			}
		}
	
		/// <summary> 
		/// Authentication object passed to handshake (only over WebSockets). <br />
		/// </summary>
		///
		public class Ext 
		{
		
			[JsonPropertyName("com.cumulocity.authn")]
			public Comcumulocityauthn? PComcumulocityauthn { get; set; }
		
			/// <summary> 
			/// The system of units to use. <br />
			/// </summary>
			///
			[JsonPropertyName("systemOfUnits")]
			public SystemOfUnits? PSystemOfUnits { get; set; }
		
			/// <summary> 
			/// The system of units to use. <br />
			/// </summary>
			///
			[JsonConverter(typeof(EnumConverterFactory))]
			public enum SystemOfUnits 
			{
				[EnumMember(Value = "imperial")]
				IMPERIAL,
				[EnumMember(Value = "metric")]
				METRIC
			}
		
			public class Comcumulocityauthn 
			{
			
				/// <summary> 
				/// Base64 encoded credentials. <br />
				/// </summary>
				///
				[JsonPropertyName("token")]
				public string? Token { get; set; }
			
				/// <summary> 
				/// Optional two factor authentication token. <br />
				/// </summary>
				///
				[JsonPropertyName("tfa")]
				public string? Tfa { get; set; }
			
				/// <summary> 
				/// Required for OAuth authentication. <br />
				/// </summary>
				///
				[JsonPropertyName("xsrfToken")]
				public string? XsrfToken { get; set; }
			
				public override string ToString()
				{
					var jsonOptions = new JsonSerializerOptions() 
					{ 
						WriteIndented = true,
						DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
					};
					return JsonSerializer.Serialize(this, jsonOptions);
				}
			}
		
		
			public override string ToString()
			{
				var jsonOptions = new JsonSerializerOptions() 
				{ 
					WriteIndented = true,
					DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
				};
				return JsonSerializer.Serialize(this, jsonOptions);
			}
		}
	
		public override string ToString()
		{
			var jsonOptions = new JsonSerializerOptions() 
			{ 
				WriteIndented = true,
				DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
			};
			return JsonSerializer.Serialize(this, jsonOptions);
		}
	}
}
